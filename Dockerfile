# ============================================================================
# Dockerfile - Spring Boot 애플리케이션을 위한 Multi-stage 빌드
# ============================================================================
#
# Multi-stage 빌드란?
# - 빌드 환경과 실행 환경을 분리하여 최종 이미지 크기를 줄이는 기법
# - 빌드에 필요한 도구(Gradle, 소스코드 등)는 최종 이미지에 포함되지 않음
# - 보안 강화: 빌드 도구와 소스코드가 프로덕션 이미지에 노출되지 않음
#
# 이미지 크기 비교 (예시):
# - Single-stage: ~800MB (JDK + Gradle + 소스코드 + JAR)
# - Multi-stage: ~300MB (JRE + JAR만 포함)
# ============================================================================

# ============================================================================
# Stage 1: 빌드 스테이지 (Build Stage)
# ============================================================================
# 목적: 소스코드를 컴파일하고 실행 가능한 JAR 파일을 생성
# 이 스테이지의 결과물(JAR 파일)만 다음 스테이지로 전달됨
# ============================================================================

# Gradle 8.12 + JDK 17 이미지를 빌드 환경으로 사용
# 'AS builder'는 이 스테이지에 이름을 부여하여 나중에 참조할 수 있게 함
FROM gradle:8.12-jdk17 AS builder

# 작업 디렉토리 설정
# 컨테이너 내부에서 모든 작업이 이 디렉토리에서 수행됨
WORKDIR /app

# ----------------------------------------------------------------------------
# 의존성 캐싱 최적화
# ----------------------------------------------------------------------------
# Docker는 레이어 캐싱을 사용함
# 파일이 변경되지 않으면 해당 레이어를 재사용
#
# 전략: 의존성 정의 파일만 먼저 복사하고 의존성을 다운로드
# 소스코드 변경 시에도 의존성 레이어는 캐시됨 -> 빌드 시간 단축
# ----------------------------------------------------------------------------

# Gradle Wrapper와 빌드 설정 파일들을 먼저 복사
# 이 파일들이 변경되지 않으면 의존성 다운로드 레이어가 캐시됨
COPY gradlew .
COPY gradle gradle
COPY build.gradle .
COPY settings.gradle .

# generateApiMeta.gradle 파일도 복사 (프로젝트 특화 설정)
# 이 파일이 없으면 빌드가 실패할 수 있음
COPY generateApiMeta.gradle .

# Gradle Wrapper에 실행 권한 부여
# Linux/Unix 환경에서 스크립트 실행을 위해 필요
RUN chmod +x ./gradlew

# 의존성만 먼저 다운로드 (캐싱 목적)
# --no-daemon: 데몬 프로세스 비활성화 (컨테이너 환경에서 권장)
# dependencies: 의존성만 다운로드하는 태스크
# 이 레이어는 build.gradle이 변경될 때만 다시 실행됨
RUN ./gradlew dependencies --no-daemon

# ----------------------------------------------------------------------------
# 소스코드 복사 및 빌드
# ----------------------------------------------------------------------------
# 소스코드는 자주 변경되므로 마지막에 복사
# 소스 변경 시 이 레이어부터 다시 빌드됨
# ----------------------------------------------------------------------------

# 전체 소스코드 복사
COPY src src

# 애플리케이션 빌드
# -x test: 테스트 스킵 (CI/CD 파이프라인에서 별도로 테스트 수행 권장)
# --no-daemon: 데몬 프로세스 비활성화
# 결과물: build/libs/*.jar
RUN ./gradlew build -x test --no-daemon

# ============================================================================
# Stage 2: 런타임 스테이지 (Runtime Stage)
# ============================================================================
# 목적: 최소한의 런타임 환경에서 애플리케이션 실행
# JDK가 아닌 JRE만 포함된 경량 이미지 사용
# ============================================================================

# Eclipse Temurin JRE 17 (Alpine Linux 기반)
# - Temurin: Eclipse 재단에서 관리하는 오픈소스 JDK/JRE
# - Alpine: 경량 Linux 배포판 (~5MB)
# - JRE: 실행만 가능 (컴파일 도구 미포함) -> 이미지 크기 감소
FROM eclipse-temurin:17-jre-alpine

# 작업 디렉토리 설정
WORKDIR /app

# ----------------------------------------------------------------------------
# 보안 강화: 비루트(non-root) 사용자 생성
# ----------------------------------------------------------------------------
# 컨테이너를 root로 실행하면 보안 위험이 있음
# 권한이 제한된 전용 사용자로 애플리케이션 실행
#
# -r: 시스템 계정 생성 (로그인 불가)
# -g appgroup: 지정된 그룹에 소속
# appuser: 사용자 이름
# ----------------------------------------------------------------------------
RUN addgroup -S appgroup && adduser -S appuser -G appgroup

# ----------------------------------------------------------------------------
# JAR 파일 복사
# ----------------------------------------------------------------------------
# --from=builder: 빌드 스테이지(builder)에서 파일을 가져옴
# 빌드 스테이지의 다른 파일들(Gradle, 소스코드 등)은 복사되지 않음
#
# 참고: *.jar 대신 정확한 파일명을 사용하면 캐싱이 더 효율적임
# 여기서는 범용성을 위해 와일드카드 사용
# ----------------------------------------------------------------------------
COPY --from=builder /app/build/libs/*.jar app.jar

# 복사된 파일의 소유권을 appuser로 변경
RUN chown appuser:appgroup app.jar

# 이후 명령들은 appuser 권한으로 실행
USER appuser

# ----------------------------------------------------------------------------
# 포트 노출
# ----------------------------------------------------------------------------
# 문서화 목적: 이 컨테이너가 8082 포트를 사용함을 명시
# 실제 포트 바인딩은 docker run -p 또는 Kubernetes Service에서 설정
# ----------------------------------------------------------------------------
EXPOSE 8082

# ----------------------------------------------------------------------------
# 헬스체크 설정 (선택사항)
# ----------------------------------------------------------------------------
# 컨테이너의 건강 상태를 주기적으로 확인
# Kubernetes에서는 주로 Probe를 사용하지만, Docker 환경에서 유용
#
# --interval: 체크 간격 (30초)
# --timeout: 응답 대기 시간 (10초)
# --start-period: 시작 후 대기 시간 (애플리케이션 초기화 시간 고려)
# --retries: 실패 허용 횟수
#
# Spring Boot Actuator의 health 엔드포인트 사용
# ----------------------------------------------------------------------------
HEALTHCHECK --interval=30s --timeout=10s --start-period=60s --retries=3 \
    CMD wget --no-verbose --tries=1 --spider http://localhost:8082/actuator/health || exit 1

# ----------------------------------------------------------------------------
# JVM 최적화 옵션
# ----------------------------------------------------------------------------
# 컨테이너 환경에 맞는 JVM 설정을 환경변수로 정의
# 실제 값은 Kubernetes Deployment에서 오버라이드 가능
#
# -XX:+UseContainerSupport: 컨테이너의 메모리/CPU 제한을 인식
# -XX:MaxRAMPercentage=75: 컨테이너 메모리의 75%를 힙으로 사용
# -Djava.security.egd: 난수 생성 속도 개선 (컨테이너 환경에서 중요)
# ----------------------------------------------------------------------------
ENV JAVA_OPTS="-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -Djava.security.egd=file:/dev/./urandom"

# ----------------------------------------------------------------------------
# 애플리케이션 시작 명령
# ----------------------------------------------------------------------------
# ENTRYPOINT: 컨테이너 시작 시 실행할 기본 명령
#
# exec: 현재 셸 프로세스를 대체 (PID 1로 Java 실행)
#       -> SIGTERM 등 신호를 Java 프로세스가 직접 수신
#       -> Graceful shutdown 가능
#
# $JAVA_OPTS: 환경변수로 JVM 옵션 주입
# -jar app.jar: Spring Boot 실행 가능 JAR 실행
#
# 참고: CMD 대신 ENTRYPOINT 사용 이유
# - ENTRYPOINT: 고정된 실행 명령 (변경하기 어려움)
# - CMD: 기본값 (docker run에서 쉽게 오버라이드 가능)
# 여기서는 셸을 통해 환경변수를 확장해야 하므로 셸 형식 사용
# ----------------------------------------------------------------------------
ENTRYPOINT ["sh", "-c", "exec java $JAVA_OPTS -jar app.jar"]

# ============================================================================
# 빌드 및 실행 명령어 예시
# ============================================================================
#
# 1. 이미지 빌드:
#    docker build -t open-green:latest .
#
# 2. 이미지 빌드 (캐시 없이):
#    docker build --no-cache -t open-green:latest .
#
# 3. 컨테이너 실행 (개발용):
#    docker run -p 8082:8082 \
#      -e SPRING_PROFILES_ACTIVE=dev \
#      -e SPRING_DATASOURCE_URL=jdbc:mysql://host.docker.internal:3306/todo \
#      open-green:latest
#
# 4. 이미지 크기 확인:
#    docker images open-green
#
# 5. 이미지 레이어 분석:
#    docker history open-green:latest
#
# ============================================================================
