# =============================================================================
# Promtail Configuration (Local Development)
# =============================================================================
# open-green Spring Boot 애플리케이션의 JSON 로그 파일을 수집하여 Loki로 전송
# 로컬 테스트용 설정
#
# 🔗 Promtail-Loki 관계 개요:
#   - Promtail: 로그 수집 에이전트 (로그 파일을 읽어서 가공 후 Loki로 전송)
#   - Loki: 로그 저장소 및 쿼리 엔진 (Promtail로부터 로그를 받아 저장)
#   - 데이터 흐름: [Log Files] → [Promtail 수집] → [Pipeline 가공] → [Loki 전송]
#
# 📁 수집 대상 로그 파일:
#   - /var/log/open-green/appLogs/*.json  (일반 애플리케이션 로그)
#   - /var/log/open-green/errorLogs/*.json (에러 로그)
#   - /var/log/open-green/*.log           (콘솔/플레인텍스트 로그)
# =============================================================================

# -----------------------------------------------------------------------------
# 🌐 서버 설정 (Promtail HTTP 서버)
# -----------------------------------------------------------------------------
# Promtail 자체의 HTTP/gRPC 서버 설정
# - 상태 확인, 메트릭 노출 등에 사용
server:
  # Promtail HTTP API 포트
  # - http://localhost:9080/ready : 준비 상태 확인
  # - http://localhost:9080/metrics : Prometheus 메트릭
  # - http://localhost:9080/targets : 수집 대상 상태
  # 🔗 [Loki 연관 없음]: Promtail 자체 관리용 포트 (Loki와 별개)
  http_listen_port: 9080

  # gRPC 포트 (0 = 비활성화)
  # - Promtail은 주로 HTTP를 사용하므로 gRPC 비활성화
  grpc_listen_port: 0

# -----------------------------------------------------------------------------
# 📍 포지션 파일 설정 (읽기 위치 추적)
# -----------------------------------------------------------------------------
# 각 로그 파일에서 마지막으로 읽은 위치를 저장
# - Promtail 재시작 시 중복 전송 방지
# - 파일별 오프셋(byte position) 기록
positions:
  # 포지션 정보 저장 파일 경로
  # - 이 파일이 없으면 로그 파일 처음부터 다시 읽음
  # - Docker 볼륨에 저장하면 컨테이너 재시작 시에도 유지 가능
  # 🔗 [Loki 연관 없음]: Promtail 내부 상태 관리용
  filename: /tmp/positions.yaml

# -----------------------------------------------------------------------------
# 📤 클라이언트 설정 (Loki 연결)
# -----------------------------------------------------------------------------
# Loki 서버로 로그를 전송하기 위한 클라이언트 설정
# 🔗 [Loki 연관 - 핵심 연결 지점]: 이 섹션이 Promtail과 Loki를 연결함
clients:
  # Loki Push API 엔드포인트
  # 🔗 [Loki 연관 - 핵심]: loki-config.yml의 server.http_listen_port(3100)와 일치해야 함
  #    - 형식: http://<loki-host>:<port>/loki/api/v1/push
  #    - Docker 네트워크에서 'loki'는 서비스 이름으로 해석됨
  - url: http://loki:3100/loki/api/v1/push

    # 배치 대기 시간
    # - 이 시간 동안 로그를 모아서 한 번에 전송
    # - 짧으면: 실시간성 향상, 네트워크 오버헤드 증가
    # - 길면: 효율성 향상, 지연 시간 증가
    # 🔗 [Loki 연관]: Loki의 chunk_idle_period(1h) 보다 훨씬 짧아야 정상 동작
    batchwait: 1s

    # 배치 크기 (바이트)
    # - 1048576 = 1MB
    # - 이 크기만큼 로그가 쌓이면 batchwait 전이라도 전송
    # 🔗 [Loki 연관 - 중요]: Loki의 제한 설정과 관련
    #    - ingestion_burst_size_mb(20MB) 보다 작아야 함 ✓
    #    - chunk_target_size(1MB)와 유사하게 설정됨
    batchsize: 1048576  # 1MB

    # 전송 타임아웃
    # - Loki 서버 응답 대기 최대 시간
    # - 타임아웃 발생 시 재시도 로직 동작
    # 🔗 [Loki 연관]: Loki 서버의 처리 시간을 고려하여 설정
    timeout: 10s

# =============================================================================
# 📥 스크레이프 설정 (로그 수집 규칙)
# =============================================================================
# 어떤 로그 파일을 어떻게 수집하고 가공할지 정의
# - job_name: 수집 작업 식별자
# - static_configs: 수집 대상 및 라벨 정의
# - pipeline_stages: 로그 가공 파이프라인
#
# 🔗 [Loki 연관 - 중요]: 여기서 정의한 라벨(labels)이 Loki에 저장되어
#    쿼리 시 필터링/그룹핑에 사용됨. 라벨이 많으면 Loki의 max_streams_per_user 제한에 영향
scrape_configs:

  # ==========================================================================
  # 📱 Application Logs (JSON) - INFO, DEBUG, WARN
  # ==========================================================================
  # Spring Boot 애플리케이션의 일반 로그 (JSON 형식)
  # - 대상 파일: /var/log/open-green/appLogs/*.json
  # - 로그 레벨: INFO, DEBUG, WARN
  - job_name: open-green-app

    # 정적 타겟 설정 (로그 소스 정의)
    static_configs:
      - targets:
          # 타겟 식별자 (실제로는 사용되지 않지만 필수 필드)
          # - Promtail은 파일 기반이므로 의미 없음
          - localhost

        # 라벨 정의 (Loki에서 쿼리 시 사용)
        # 🔗 [Loki 연관 - 핵심]: 이 라벨들이 Loki의 인덱스가 됨
        #    - 라벨 조합의 수 = 스트림 수 (max_streams_per_user 제한 적용)
        #    - 예: job="open-green", env="local", log_type="app" → 1개 스트림
        labels:
          # 작업 이름 (프로젝트/애플리케이션 식별)
          # 🔗 [Loki 쿼리]: {job="open-green"} 으로 필터링 가능
          job: open-green

          # 환경 식별자 (local, dev, staging, prod 등)
          # 🔗 [Loki 쿼리]: {env="local"} 으로 환경별 필터링
          env: local

          # 인스턴스 식별자 (다중 인스턴스 구분용)
          # - 스케일아웃 시 app-1, app-2 등으로 구분
          # 🔗 [Loki 쿼리]: {instance="app-1"} 으로 인스턴스별 필터링
          instance: app-1

          # 로그 타입 (app, error, console 등 구분)
          # - 같은 애플리케이션 내 로그 종류 구분
          # 🔗 [Loki 쿼리]: {log_type="app"} 으로 로그 타입별 필터링
          log_type: app

          # 수집할 파일 경로 패턴 (특수 라벨)
          # - __path__는 Promtail 내부에서 사용되며 Loki에 전송되지 않음
          # - 와일드카드(*) 사용 가능
          # 🔗 [Docker 연관]: docker-compose.yml의 볼륨 마운트 경로와 일치해야 함
          #    - ../../logs → /var/log/open-green
          __path__: /var/log/open-green/appLogs/*.json

    # 파이프라인 스테이지 (로그 가공 단계)
    # - 순서대로 실행되며, 각 단계의 출력이 다음 단계의 입력이 됨
    # 🔗 [Loki 연관]: 파이프라인에서 추출한 라벨과 메시지가 Loki에 저장됨
    pipeline_stages:

      # -----------------------------------------------------------------------
      # Stage 1: JSON 파싱 - 필요한 필드만 추출
      # -----------------------------------------------------------------------
      # Spring Boot의 JSON 로그에서 필드를 추출하여 내부 변수로 저장
      # - 입력: JSON 형식 로그 라인
      # - 출력: 파싱된 필드들 (level, message, traceId 등)
      - json:
          expressions:
            # 로그 레벨 (INFO, DEBUG, WARN, ERROR)
            # - JSON의 "level" 필드를 "level" 변수에 저장
            level: level

            # 로그 메시지 본문
            # - JSON의 "message" 필드를 "message" 변수에 저장
            message: message

            # 분산 추적 ID (Spring Cloud Sleuth/Micrometer Tracing)
            # - 마이크로서비스 간 요청 추적에 사용
            # 🔗 [Loki 쿼리]: {traceId="abc123"} 으로 전체 요청 흐름 추적
            traceId: traceId

            # 스팬 ID (단일 서비스 내 작업 단위)
            spanId: spanId

            # 서비스 이름
            # - 마이크로서비스 환경에서 서비스 식별
            service: service

            # 로거 이름 (패키지/클래스명)
            # - com.example.service.UserService 등
            logger: logger_name

            # 스레드 이름
            # - http-nio-8080-exec-1 등
            thread: thread_name

      # -----------------------------------------------------------------------
      # Stage 2: 라벨 추출 - 쿼리 가능한 라벨로 변환
      # -----------------------------------------------------------------------
      # 파싱된 필드 중 일부를 Loki 라벨로 승격
      # 🔗 [Loki 연관 - 중요]: 여기서 라벨로 지정된 필드만 Loki에서 인덱싱됨
      #    - 라벨: 빠른 검색 가능, 스트림 수에 영향
      #    - 필드: 전체 텍스트 검색만 가능, 스트림 수에 영향 없음
      # ⚠️ 주의: 라벨이 많거나 카디널리티가 높으면 성능 저하
      #    - level: 낮은 카디널리티 (INFO, DEBUG, WARN, ERROR) ✓
      #    - traceId: 높은 카디널리티 (요청당 고유값) - 신중히 사용
      - labels:
          # 로그 레벨을 라벨로 추가
          # 🔗 [Loki 쿼리]: {level="ERROR"} 으로 에러만 필터링
          level:

          # 추적 ID를 라벨로 추가 (선택적 - 카디널리티 주의)
          # 🔗 [Loki 쿼리]: {traceId="abc123"} 으로 특정 요청 추적
          traceId:

          # 스팬 ID를 라벨로 추가
          spanId:

          # 서비스 이름을 라벨로 추가
          # 🔗 [Loki 쿼리]: {service="user-service"} 으로 서비스별 필터링
          service:

          # 로거 이름을 라벨로 추가
          # 🔗 [Loki 쿼리]: {logger=~"com.example..*"} 정규식 필터링
          logger:

      # -----------------------------------------------------------------------
      # Stage 3: 출력 포맷 - Loki에 저장될 로그 본문 설정
      # -----------------------------------------------------------------------
      # 어떤 필드를 로그 본문(log line)으로 저장할지 결정
      # 🔗 [Loki 연관]: 이 출력이 Loki에 저장되는 실제 로그 내용
      - output:
          # message 필드를 로그 본문으로 사용
          # - JSON 전체가 아닌 message 필드만 저장 (용량 절약)
          source: message

  # ==========================================================================
  # 🚨 Error Logs (JSON) - ERROR only
  # ==========================================================================
  # Spring Boot 에러 전용 로그 (스택트레이스 포함)
  # - 대상 파일: /var/log/open-green/errorLogs/*.json
  # - 로그 레벨: ERROR
  - job_name: open-green-error

    static_configs:
      - targets:
          - localhost
        labels:
          # 동일한 job으로 통합 관리
          # 🔗 [Loki 쿼리]: {job="open-green", log_type="error"} 로 에러만 조회
          job: open-green
          env: local
          instance: app-1

          # 에러 로그 타입으로 구분
          # - app 로그와 구분하여 별도 대시보드 구성 가능
          log_type: error

          # 에러 로그 전용 디렉토리
          # 🔗 [Spring Boot 연관]: logback 설정에서 errorLogs 디렉토리로 분리 필요
          __path__: /var/log/open-green/errorLogs/*.json

    pipeline_stages:
      # -----------------------------------------------------------------------
      # Stage 1: JSON 파싱 (스택트레이스 필드 추가)
      # -----------------------------------------------------------------------
      - json:
          expressions:
            level: level
            message: message
            traceId: traceId
            spanId: spanId
            service: service
            logger: logger_name
            thread: thread_name

            # 스택트레이스 (에러 로그 전용)
            # - Java 예외의 전체 스택트레이스
            # 🔗 [Loki 저장]: 스택트레이스는 라벨이 아닌 본문에 포함
            stackTrace: stack_trace

      # -----------------------------------------------------------------------
      # Stage 2: 라벨 추출
      # -----------------------------------------------------------------------
      - labels:
          level:
          traceId:
          spanId:
          service:
          logger:

      # -----------------------------------------------------------------------
      # Stage 3: 템플릿 처리 - 메시지와 스택트레이스 결합
      # -----------------------------------------------------------------------
      # Go 템플릿을 사용하여 출력 형식 커스터마이징
      # - 메시지 + 스택트레이스를 하나의 로그 라인으로 결합
      - template:
          # 출력 변수 이름
          source: output_msg

          # Go 템플릿 문법
          # - {{ .message }}: 에러 메시지
          # - {{ if .stackTrace }}: 스택트레이스 존재 시에만 추가
          # - 줄바꿈으로 구분하여 가독성 확보
          # 🔗 [Loki 저장]: 스택트레이스 포함 전체가 하나의 로그 라인으로 저장
          # ⚠️ [Loki 연관]: max_line_size(256kb) 제한 고려
          template: '{{ .message }}{{ if .stackTrace }}
{{ .stackTrace }}{{ end }}'

      # -----------------------------------------------------------------------
      # Stage 4: 출력 - 가공된 메시지를 로그 본문으로 설정
      # -----------------------------------------------------------------------
      - output:
          # 템플릿으로 생성된 output_msg를 최종 출력으로 사용
          source: output_msg

  # ==========================================================================
  # 📜 Console/Plain Text Logs (fallback)
  # ==========================================================================
  # JSON이 아닌 일반 텍스트 로그 (콘솔 출력 등)
  # - 대상 파일: /var/log/open-green/*.log
  # - 형식: 플레인 텍스트 (날짜로 시작하는 멀티라인)
  - job_name: open-green-console

    static_configs:
      - targets:
          - localhost
        labels:
          job: open-green
          env: local
          instance: app-1

          # 콘솔 로그 타입
          # - JSON 파싱 실패 시 fallback으로 사용
          log_type: console

          # .log 확장자 파일 수집
          # - 기존 logback 설정의 파일 로그
          __path__: /var/log/open-green/*.log

    pipeline_stages:
      # -----------------------------------------------------------------------
      # Stage 1: 멀티라인 처리 - 여러 줄의 로그를 하나로 결합
      # -----------------------------------------------------------------------
      # Java 스택트레이스 등 여러 줄에 걸친 로그를 하나의 로그 엔트리로 처리
      - multiline:
          # 새 로그 라인의 시작 패턴 (정규식)
          # - 날짜 형식으로 시작하는 라인이 새 로그의 시작
          # - 형식: 2024-01-15 10:30:45.123 ...
          # - 이 패턴과 일치하지 않는 라인은 이전 로그에 연결됨
          firstline: '^\d{4}-\d{2}-\d{2}'

          # 멀티라인 대기 시간
          # - 새 로그 라인이 이 시간 동안 오지 않으면 현재 로그 완료로 처리
          # - 스택트레이스 전체가 수집될 때까지 기다림
          # 🔗 [Loki 연관]: 너무 길면 로그 지연, 너무 짧으면 스택트레이스 분리
          max_wait_time: 3s
