# ============================================================================
# Deployment - 로컬 테스트용 Spring Boot 애플리케이션 배포 설정
# ============================================================================
#
# Deployment란?
# - Pod의 복제본을 생성하고 관리하는 Kubernetes 리소스
# - 선언적 업데이트: 원하는 상태(Desired State)를 선언하면 자동으로 달성
# - 롤링 업데이트, 롤백, 스케일링 기능 제공
#
# 왜 Pod를 직접 만들지 않고 Deployment를 사용하나요?
# 1. Pod는 삭제되면 자동으로 재생성되지 않음
# 2. Deployment는 ReplicaSet을 통해 Pod 수를 자동으로 유지
# 3. 업데이트 시 무중단 배포(Rolling Update) 가능
# 4. 문제 발생 시 이전 버전으로 쉽게 롤백 가능
#
# ============================================================================

apiVersion: apps/v1  # Deployment API 버전
kind: Deployment     # 리소스 타입

# ============================================================================
# 메타데이터 (Metadata)
# ============================================================================
# 리소스를 식별하고 구분하는 정보
# ============================================================================

metadata:
  # Deployment 이름 (클러스터 내에서 고유해야 함)
  name: open-green-local

  # 네임스페이스 (리소스를 논리적으로 그룹화)
  # 지정하지 않으면 'default' 네임스페이스 사용
  namespace: default

  # 레이블 (Key-Value 쌍으로 리소스를 분류)
  # kubectl get deployments -l app=open-green 같은 필터링에 사용
  labels:
    app: open-green           # 애플리케이션 이름
    version: local-test       # 버전 정보
    environment: local        # 환경 구분 (local, dev, staging, prod)
    managed-by: kubectl       # 관리 도구

  # 어노테이션 (추가 메타데이터, 도구나 라이브러리가 사용)
  # 레이블과 달리 선택 기준으로 사용되지 않음
  annotations:
    description: "로컬 테스트용 Spring Boot 애플리케이션"
    contact: "developer@example.com"
    # kubectl.kubernetes.io/last-applied-configuration은 자동으로 추가됨

# ============================================================================
# 스펙 (Spec) - Deployment 설정
# ============================================================================
# Deployment가 어떻게 동작할지 정의
# ============================================================================

spec:
  # --------------------------------------------------------------------------
  # 복제본 수 (Replicas)
  # --------------------------------------------------------------------------
  # 동시에 실행될 Pod의 개수
  #
  # 로컬 테스트: 1-2개 (리소스 절약)
  # 개발 환경: 2-3개 (기본 HA)
  # 프로덕션: 3개 이상 (고가용성)
  #
  # 참고: HPA(자동 스케일링) 사용 시 이 값은 최소값으로 동작
  # --------------------------------------------------------------------------
  replicas: 2

  # --------------------------------------------------------------------------
  # 셀렉터 (Selector)
  # --------------------------------------------------------------------------
  # 이 Deployment가 관리할 Pod를 선택하는 기준
  # Pod의 레이블과 일치해야 함 (spec.template.metadata.labels)
  #
  # matchLabels: 모든 레이블이 일치해야 함 (AND 조건)
  # matchExpressions: 더 복잡한 선택 조건 (IN, NotIn, Exists, DoesNotExist)
  # --------------------------------------------------------------------------
  selector:
    matchLabels:
      app: open-green
      environment: local

  # --------------------------------------------------------------------------
  # 롤링 업데이트 전략 (Strategy)
  # --------------------------------------------------------------------------
  # 새 버전 배포 시 어떻게 업데이트할지 정의
  #
  # RollingUpdate: 점진적 업데이트 (기본값, 무중단 배포)
  # Recreate: 모든 Pod 삭제 후 새로 생성 (다운타임 발생)
  # --------------------------------------------------------------------------
  strategy:
    type: RollingUpdate
    rollingUpdate:
      # 동시에 생성할 수 있는 추가 Pod 수
      # 예: replicas=2, maxSurge=1 -> 업데이트 중 최대 3개 Pod 실행
      # 값: 절대값(1, 2, ...) 또는 비율(25%, 50%, ...)
      maxSurge: 1

      # 동시에 사용 불가능한 Pod 수
      # 예: replicas=2, maxUnavailable=1 -> 업데이트 중 최소 1개 Pod 실행 유지
      # 0으로 설정하면 무중단 보장 (단, maxSurge > 0 필요)
      maxUnavailable: 0

  # --------------------------------------------------------------------------
  # Pod 템플릿 (Template)
  # --------------------------------------------------------------------------
  # 생성할 Pod의 청사진
  # Deployment는 이 템플릿을 사용하여 Pod를 생성
  # --------------------------------------------------------------------------
  template:
    # Pod 메타데이터
    metadata:
      labels:
        # 위의 selector.matchLabels와 일치해야 함
        app: open-green
        environment: local
        version: "1.0.0"

      annotations:
        # Prometheus 스크래핑 설정 (모니터링)
        prometheus.io/scrape: "true"
        prometheus.io/port: "8082"
        prometheus.io/path: "/actuator/prometheus"

    # Pod 스펙
    spec:
      # ----------------------------------------------------------------------
      # 컨테이너 목록
      # ----------------------------------------------------------------------
      # 하나의 Pod에 여러 컨테이너를 실행할 수 있음 (사이드카 패턴)
      # 대부분의 경우 메인 컨테이너 1개만 사용
      # ----------------------------------------------------------------------
      containers:
        - name: app  # 컨테이너 이름 (Pod 내에서 고유)

          # --------------------------------------------------------------------
          # 컨테이너 이미지
          # --------------------------------------------------------------------
          # Docker 이미지 경로 및 태그
          # 형식: [레지스트리/]이미지명[:태그]
          #
          # 로컬 이미지 사용 시 주의사항:
          # 1. kind load docker-image 명령으로 미리 로드 필요
          # 2. imagePullPolicy를 IfNotPresent 또는 Never로 설정
          # --------------------------------------------------------------------
          image: open-green:local-test

          # 이미지 풀 정책
          # Always: 항상 레지스트리에서 다운로드 (기본값, :latest 태그 사용 시)
          # IfNotPresent: 로컬에 없을 때만 다운로드 (권장, 로컬 테스트)
          # Never: 로컬 이미지만 사용, 없으면 실패
          imagePullPolicy: IfNotPresent

          # --------------------------------------------------------------------
          # 포트 설정
          # --------------------------------------------------------------------
          # 컨테이너가 노출하는 포트 목록
          # 문서화 목적이며, 실제 포트는 애플리케이션에서 열림
          # Service에서 이 포트로 트래픽을 전달함
          # --------------------------------------------------------------------
          ports:
            - name: http           # 포트 이름 (Service에서 참조 가능)
              containerPort: 8082  # 컨테이너 내부 포트
              protocol: TCP        # 프로토콜 (TCP, UDP, SCTP)

          # --------------------------------------------------------------------
          # 환경 변수
          # --------------------------------------------------------------------
          # 컨테이너에 주입할 환경 변수
          # Spring Boot는 환경 변수로 설정을 오버라이드 가능
          #
          # 값 소스:
          # 1. value: 직접 값 지정
          # 2. valueFrom: ConfigMap, Secret, Field 등에서 가져오기
          # --------------------------------------------------------------------
          env:
            # Spring Profile 설정 (dev, test, prod)
            - name: SPRING_PROFILES_ACTIVE
              value: "local"

            # 애플리케이션 포트
            - name: SERVER_PORT
              value: "8082"

            # ConfigMap에서 값 가져오기 예시
            - name: DATABASE_URL
              valueFrom:
                configMapKeyRef:
                  name: open-green-config  # ConfigMap 이름
                  key: database.url        # ConfigMap의 키

            # Secret에서 값 가져오기 예시
            - name: DATABASE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: open-green-secret  # Secret 이름
                  key: db.password         # Secret의 키

            # JVM 메모리 설정
            - name: JAVA_OPTS
              value: "-Xms256m -Xmx512m"

          # --------------------------------------------------------------------
          # 리소스 요청 및 제한 (Resource Requests & Limits)
          # --------------------------------------------------------------------
          # Pod 스케줄링과 리소스 관리에 사용
          #
          # Requests (요청):
          # - 이 Pod가 최소한 필요로 하는 리소스
          # - 스케줄러가 Pod를 배치할 노드를 선택할 때 사용
          # - 이 양만큼의 리소스가 있는 노드에만 배치됨
          #
          # Limits (제한):
          # - Pod가 사용할 수 있는 최대 리소스
          # - 초과 시 컨테이너가 제한됨 (CPU: throttling, Memory: OOM Kill)
          #
          # 권장 사항:
          # - 로컬 테스트: 최소한으로 설정
          # - 프로덕션: 모니터링 데이터 기반으로 설정
          # --------------------------------------------------------------------
          resources:
            requests:
              # CPU: 0.25 코어 (250m = 250 milli-CPU = 0.25 core)
              # 1000m = 1 core
              cpu: "250m"

              # 메모리: 512MB
              # 단위: Ki, Mi, Gi (2진수) 또는 K, M, G (10진수)
              memory: "512Mi"

            limits:
              # 최대 CPU: 1 코어
              cpu: "1000m"

              # 최대 메모리: 1GB
              # 초과 시 Pod가 종료(OOMKilled)될 수 있음
              memory: "1Gi"

          # --------------------------------------------------------------------
          # Liveness Probe (생존 확인)
          # --------------------------------------------------------------------
          # 컨테이너가 살아있는지 확인
          # 실패 시 kubelet이 컨테이너를 재시작
          #
          # 사용 시나리오:
          # - 애플리케이션이 데드락에 빠졌을 때
          # - 응답은 하지만 정상 동작하지 않을 때
          #
          # 프로브 타입:
          # - httpGet: HTTP GET 요청 (권장)
          # - tcpSocket: TCP 포트 연결
          # - exec: 명령어 실행
          # --------------------------------------------------------------------
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness  # Spring Boot Actuator 엔드포인트
              port: 8082                       # 포트 번호
              scheme: HTTP                     # HTTP 또는 HTTPS

            # 컨테이너 시작 후 대기 시간 (애플리케이션 초기화 시간)
            # Spring Boot는 시작 시간이 걸리므로 충분히 설정
            initialDelaySeconds: 60

            # 체크 간격 (초)
            periodSeconds: 10

            # 타임아웃 (초) - 이 시간 내에 응답 없으면 실패
            timeoutSeconds: 5

            # 성공으로 간주할 연속 성공 횟수
            successThreshold: 1

            # 실패로 간주할 연속 실패 횟수
            # 이 횟수만큼 연속 실패하면 컨테이너 재시작
            failureThreshold: 3

          # --------------------------------------------------------------------
          # Readiness Probe (준비 확인)
          # --------------------------------------------------------------------
          # 컨테이너가 트래픽을 받을 준비가 되었는지 확인
          # 실패 시 Service의 엔드포인트에서 제거 (트래픽 차단)
          # 재시작하지 않음 (Liveness와의 차이)
          #
          # 사용 시나리오:
          # - 데이터베이스 연결 대기 중
          # - 캐시 워밍업 중
          # - 일시적인 과부하 상태
          # --------------------------------------------------------------------
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8082
              scheme: HTTP

            # Readiness는 초기 대기 시간을 짧게 설정
            # 빨리 준비 상태를 확인하여 트래픽을 받기 시작
            initialDelaySeconds: 30

            periodSeconds: 5
            timeoutSeconds: 3
            successThreshold: 1
            failureThreshold: 3

          # --------------------------------------------------------------------
          # Startup Probe (시작 확인) - Kubernetes 1.16+
          # --------------------------------------------------------------------
          # 애플리케이션이 시작되었는지 확인
          # 성공하기 전까지 Liveness/Readiness Probe 실행 안 됨
          #
          # 사용 시나리오:
          # - 시작 시간이 긴 레거시 애플리케이션
          # - Liveness Probe가 시작 중에 실패하는 것을 방지
          # --------------------------------------------------------------------
          startupProbe:
            httpGet:
              path: /actuator/health
              port: 8082
              scheme: HTTP

            # 시작 확인은 더 느긋하게 설정
            initialDelaySeconds: 10
            periodSeconds: 10
            timeoutSeconds: 5

            # 최대 대기 시간: failureThreshold * periodSeconds
            # 여기서는 30 * 10 = 300초 (5분)
            failureThreshold: 30

      # ----------------------------------------------------------------------
      # Restart Policy (재시작 정책)
      # ----------------------------------------------------------------------
      # Pod가 종료되었을 때 어떻게 할지 결정
      #
      # Always: 항상 재시작 (기본값, Deployment에서 사용)
      # OnFailure: 실패 시만 재시작 (Job에서 사용)
      # Never: 재시작 안 함
      # ----------------------------------------------------------------------
      restartPolicy: Always

      # ----------------------------------------------------------------------
      # DNS 정책
      # ----------------------------------------------------------------------
      # ClusterFirst: 클러스터 내부 DNS 우선 사용 (기본값)
      # Default: 노드의 DNS 설정 사용
      # None: dnsConfig에서 직접 설정
      # ----------------------------------------------------------------------
      dnsPolicy: ClusterFirst

      # ----------------------------------------------------------------------
      # 종료 유예 시간 (Termination Grace Period)
      # ----------------------------------------------------------------------
      # Pod 삭제 시 SIGTERM 전송 후 SIGKILL까지 대기 시간 (초)
      # Spring Boot는 Graceful Shutdown 지원하므로 충분한 시간 필요
      #
      # 이 시간 동안:
      # 1. SIGTERM 신호 전송
      # 2. 애플리케이션이 현재 요청 처리 완료
      # 3. 새 요청 거부
      # 4. 정리 작업 수행 (DB 연결 종료 등)
      # 5. 시간 초과 시 SIGKILL로 강제 종료
      # ----------------------------------------------------------------------
      terminationGracePeriodSeconds: 30

      # ----------------------------------------------------------------------
      # Image Pull Secrets (이미지 풀 시크릿)
      # ----------------------------------------------------------------------
      # Private Docker Registry 사용 시 인증 정보
      # Docker Hub, AWS ECR, GCR 등에서 이미지를 가져올 때 필요
      #
      # 생성 방법:
      # kubectl create secret docker-registry regcred \
      #   --docker-server=<레지스트리 URL> \
      #   --docker-username=<사용자명> \
      #   --docker-password=<비밀번호> \
      #   --docker-email=<이메일>
      # ----------------------------------------------------------------------
      # imagePullSecrets:
      #   - name: regcred

      # ----------------------------------------------------------------------
      # 보안 컨텍스트 (Security Context)
      # ----------------------------------------------------------------------
      # 보안 관련 설정
      #
      # runAsNonRoot: root가 아닌 사용자로 실행 강제
      # runAsUser: 특정 UID로 실행
      # fsGroup: 파일시스템 그룹 ID
      # ----------------------------------------------------------------------
      securityContext:
        # root가 아닌 사용자로 실행 (보안 강화)
        runAsNonRoot: true

        # 사용자 ID (Dockerfile에서 지정한 appuser의 UID)
        runAsUser: 1000

        # 파일시스템 그룹 ID
        fsGroup: 1000

# ============================================================================
# 배포 및 관리 명령어
# ============================================================================
#
# 1. Deployment 생성:
#    kubectl apply -f deployment-local.yaml
#
# 2. Deployment 상태 확인:
#    kubectl get deployment open-green-local
#    kubectl describe deployment open-green-local
#
# 3. Pod 확인:
#    kubectl get pods -l app=open-green
#
# 4. 로그 확인:
#    kubectl logs -l app=open-green --tail=100 -f
#
# 5. 스케일링:
#    kubectl scale deployment open-green-local --replicas=3
#
# 6. 롤링 업데이트 (이미지 변경):
#    kubectl set image deployment/open-green-local app=open-green:v2
#
# 7. 롤아웃 상태 확인:
#    kubectl rollout status deployment/open-green-local
#
# 8. 롤백:
#    kubectl rollout undo deployment/open-green-local
#
# 9. 롤아웃 히스토리:
#    kubectl rollout history deployment/open-green-local
#
# 10. Deployment 삭제:
#     kubectl delete deployment open-green-local
#
# ============================================================================

# ============================================================================
# 학습 체크리스트
# ============================================================================
#
# □ Deployment와 Pod의 차이를 이해했나요?
# □ replicas의 의미와 스케일링 방법을 알고 있나요?
# □ Rolling Update 전략의 동작 방식을 이해했나요?
# □ Resources (requests/limits)의 차이를 알고 있나요?
# □ Liveness, Readiness, Startup Probe의 차이를 이해했나요?
# □ 환경 변수를 ConfigMap과 Secret에서 가져오는 방법을 알고 있나요?
# □ Graceful Shutdown이 왜 중요한지 이해했나요?
#
# ============================================================================
