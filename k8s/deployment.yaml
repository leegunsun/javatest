# ============================================================================
# deployment.yaml - Kubernetes Deployment 리소스
# ============================================================================
#
# Deployment란?
# - Pod의 선언적 업데이트를 제공하는 컨트롤러
# - 원하는 상태(desired state)를 정의하면 Kubernetes가 현재 상태를 맞춤
# - 롤링 업데이트, 롤백, 스케일링을 자동으로 관리
#
# Deployment vs Pod:
# - Pod: 단일 인스턴스, 자동 복구 없음
# - Deployment: 복제본 관리, 자동 복구, 업데이트 전략 제공
#
# 핵심 개념:
# - ReplicaSet: 지정된 수의 Pod 복제본을 유지
# - Pod Template: 생성할 Pod의 스펙 정의
# - Selector: 어떤 Pod을 관리할지 선택
# ============================================================================

# apiVersion: 사용할 Kubernetes API 버전
# apps/v1은 Deployment를 포함한 워크로드 리소스를 정의
apiVersion: apps/v1
# kind: 리소스 타입
kind: Deployment
# metadata: 리소스의 메타데이터 (이름, 레이블 등)
metadata:
  # name: Deployment의 고유 이름
  # kubectl get deployment로 조회할 때 이 이름으로 표시됨
  name: open-green-deployment

  # namespace: 이 리소스가 속할 네임스페이스
  # 생략하면 default 네임스페이스에 생성됨
  # 환경별로 네임스페이스를 분리하는 것이 좋은 관행
  # 예: dev, staging, production
  namespace: default

  # labels: 리소스를 분류하고 선택하기 위한 키-값 쌍
  # 다른 리소스(Service, HPA 등)가 이 레이블로 Deployment를 찾음
  labels:
    # app: 애플리케이션 이름 (관례적으로 많이 사용)
    app: open-green
    # 추가 레이블로 버전, 환경 등을 표시할 수 있음
    version: v1
    environment: production

# spec: Deployment의 원하는 상태 정의
spec:
  # --------------------------------------------------------------------------
  # replicas: Pod 복제본 수
  # --------------------------------------------------------------------------
  # 몇 개의 동일한 Pod을 실행할지 지정
  # - 고가용성: 최소 2개 이상 권장
  # - 부하 분산: Service가 여러 Pod에 트래픽 분산
  # - HPA가 이 값을 자동으로 조절할 수 있음
  # --------------------------------------------------------------------------
  replicas: 2

  # --------------------------------------------------------------------------
  # selector: 이 Deployment가 관리할 Pod을 선택하는 조건
  # --------------------------------------------------------------------------
  # matchLabels의 레이블과 일치하는 Pod만 관리
  # template.metadata.labels와 반드시 일치해야 함!
  # --------------------------------------------------------------------------
  selector:
    matchLabels:
      app: open-green

  # --------------------------------------------------------------------------
  # strategy: 업데이트 전략
  # --------------------------------------------------------------------------
  # 새 버전 배포 시 어떻게 Pod을 교체할지 정의
  #
  # 전략 유형:
  # 1. RollingUpdate (기본): 점진적으로 새 Pod으로 교체
  # 2. Recreate: 모든 기존 Pod을 삭제 후 새 Pod 생성 (다운타임 발생)
  # --------------------------------------------------------------------------
  strategy:
    type: RollingUpdate
    rollingUpdate:
      # maxSurge: 업데이트 중 replicas 초과로 생성할 수 있는 Pod 수
      # 25% = replicas가 2개면 0.5 -> 반올림하여 1개 추가 가능 (총 3개)
      # 새 버전 Pod을 먼저 생성하고 트래픽을 받으면 기존 Pod 삭제
      maxSurge: 25%

      # maxUnavailable: 업데이트 중 사용 불가능할 수 있는 최대 Pod 수
      # 25% = replicas가 2개면 0.5 -> 반내림하여 0개
      # 0이면 항상 최소 replicas 수의 Pod이 사용 가능
      maxUnavailable: 25%

  # --------------------------------------------------------------------------
  # revisionHistoryLimit: 유지할 ReplicaSet 히스토리 수
  # --------------------------------------------------------------------------
  # 롤백을 위해 이전 버전의 ReplicaSet을 얼마나 보관할지
  # kubectl rollout undo로 롤백할 때 사용
  # --------------------------------------------------------------------------
  revisionHistoryLimit: 5

  # --------------------------------------------------------------------------
  # template: 생성할 Pod의 템플릿
  # --------------------------------------------------------------------------
  # 이 템플릿을 기반으로 Pod이 생성됨
  # --------------------------------------------------------------------------
  template:
    # Pod의 메타데이터
    metadata:
      labels:
        # selector.matchLabels와 일치해야 함!
        app: open-green
        version: v1
      # annotations: 추가 메타데이터 (선택적)
      annotations:
        # Prometheus가 이 Pod의 메트릭을 수집하도록 설정
        prometheus.io/scrape: "true"
        prometheus.io/port: "8082"
        prometheus.io/path: "/actuator/prometheus"

    # Pod의 스펙
    spec:
      # ----------------------------------------------------------------------
      # serviceAccountName: Pod이 사용할 ServiceAccount
      # ----------------------------------------------------------------------
      # Kubernetes API 접근 권한을 제어
      # 기본 default ServiceAccount 사용 또는 전용 계정 생성
      # ----------------------------------------------------------------------
      serviceAccountName: default

      # ----------------------------------------------------------------------
      # terminationGracePeriodSeconds: Pod 종료 유예 시간
      # ----------------------------------------------------------------------
      # Pod 삭제 요청 후 강제 종료까지 대기 시간 (초)
      # Graceful Shutdown을 위해 충분한 시간 필요
      # Spring Boot의 spring.lifecycle.timeout-per-shutdown-phase보다 길어야 함
      # ----------------------------------------------------------------------
      terminationGracePeriodSeconds: 60

      # ----------------------------------------------------------------------
      # containers: Pod 내에서 실행할 컨테이너 정의
      # ----------------------------------------------------------------------
      # 하나의 Pod에 여러 컨테이너 가능 (사이드카 패턴)
      # 여기서는 메인 애플리케이션 컨테이너 1개만 정의
      # ----------------------------------------------------------------------
      containers:
        - name: open-green
          # ----------------------------------------------------------------
          # image: 사용할 컨테이너 이미지
          # ----------------------------------------------------------------
          # 형식: <registry>/<repository>:<tag>
          # 예: docker.io/myrepo/open-green:v1.0.0
          #
          # 태그 전략:
          # - latest: 비권장 (버전 추적 어려움)
          # - 버전 태그: v1.0.0 (권장)
          # - Git SHA: abc123 (CI/CD에서 자주 사용)
          # ----------------------------------------------------------------
          image: open-green:latest

          # imagePullPolicy: 이미지 가져오기 정책
          # - Always: 항상 새로 가져옴 (개발용)
          # - IfNotPresent: 로컬에 없을 때만 가져옴 (권장)
          # - Never: 로컬 이미지만 사용
          imagePullPolicy: IfNotPresent

          # ----------------------------------------------------------------
          # ports: 컨테이너가 노출하는 포트
          # ----------------------------------------------------------------
          # 문서화 목적 + Service가 참조할 수 있음
          # 실제 네트워크 노출은 Service에서 설정
          # ----------------------------------------------------------------
          ports:
            - name: http
              # containerPort: 컨테이너 내부 포트
              containerPort: 8082
              # protocol: TCP(기본), UDP
              protocol: TCP

          # ----------------------------------------------------------------
          # env: 환경변수 설정
          # ----------------------------------------------------------------
          # 애플리케이션 설정을 외부에서 주입
          # ConfigMap, Secret 참조 또는 직접 값 설정 가능
          # ----------------------------------------------------------------
          env:
            # Spring 프로파일 활성화
            - name: SPRING_PROFILES_ACTIVE
              value: "k8s"

            # JVM 옵션 - 컨테이너 환경 최적화
            - name: JAVA_OPTS
              # -XX:+UseContainerSupport: 컨테이너 리소스 제한 인식
              # -XX:MaxRAMPercentage=75: 힙을 메모리의 75%로 설정
              # -XX:+UseG1GC: G1 가비지 컬렉터 사용 (대용량 힙에 적합)
              value: "-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0 -XX:+UseG1GC -Djava.security.egd=file:/dev/./urandom"

            # ============================================================
            # ConfigMap에서 주입받는 환경변수 (비민감 정보)
            # ============================================================
            # 데이터베이스 URL
            - name: SPRING_DATASOURCE_URL
              valueFrom:
                configMapKeyRef:
                  name: open-green-config  # ConfigMap 이름
                  key: database-url        # ConfigMap 내의 키

            # Redis 호스트
            - name: SPRING_REDIS_HOST
              valueFrom:
                configMapKeyRef:
                  name: open-green-config
                  key: redis-host

            # Kafka 브로커
            - name: SPRING_KAFKA_BOOTSTRAP_SERVERS
              valueFrom:
                configMapKeyRef:
                  name: open-green-config
                  key: kafka-bootstrap-servers

            # ============================================================
            # Secret에서 주입받는 환경변수 (민감 정보)
            # ============================================================
            # 데이터베이스 사용자명
            - name: SPRING_DATASOURCE_USERNAME
              valueFrom:
                secretKeyRef:
                  name: open-green-secret  # Secret 이름
                  key: database-username   # Secret 내의 키

            # 데이터베이스 비밀번호
            - name: SPRING_DATASOURCE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: open-green-secret
                  key: database-password

            # Redis 비밀번호 (설정된 경우)
            - name: SPRING_REDIS_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: open-green-secret
                  key: redis-password
                  optional: true  # 키가 없어도 에러 발생하지 않음

          # ----------------------------------------------------------------
          # resources: 리소스 제한 및 요청
          # ----------------------------------------------------------------
          # Kubernetes 스케줄러가 Pod 배치에 사용
          # 리소스 제한을 통해 노드 보호
          #
          # requests: 최소 보장 리소스 (스케줄링 기준)
          # limits: 최대 사용 가능 리소스 (초과 시 제한/종료)
          #
          # 모범 사례:
          # - requests와 limits를 항상 설정
          # - requests <= limits
          # - memory limits 초과 시 OOMKilled
          # - cpu limits 초과 시 throttling
          # ----------------------------------------------------------------
          resources:
            requests:
              # 최소 메모리: 512Mi
              # Spring Boot는 최소 512MB 권장
              memory: "512Mi"
              # 최소 CPU: 250m (0.25 코어)
              # 'm'은 밀리코어 (1000m = 1 코어)
              cpu: "250m"
            limits:
              # 최대 메모리: 1Gi
              # 초과 시 OOMKilled로 Pod 재시작
              memory: "1Gi"
              # 최대 CPU: 1000m (1 코어)
              # 초과 시 throttling (느려짐)
              cpu: "1000m"

          # ----------------------------------------------------------------
          # livenessProbe: 생존 프로브
          # ----------------------------------------------------------------
          # 애플리케이션이 살아있는지 확인
          # 실패 시: 컨테이너 재시작
          #
          # 사용 사례:
          # - 데드락 감지
          # - 무한 루프 감지
          # - 메모리 누수로 인한 응답 불가 감지
          #
          # 주의: livenessProbe 실패 = 재시작
          # 외부 의존성(DB, Redis) 체크는 하지 않는 것이 좋음
          # 외부 서비스 장애 시 모든 Pod이 재시작되는 문제 방지
          # ----------------------------------------------------------------
          livenessProbe:
            httpGet:
              # Spring Boot Actuator의 liveness 전용 엔드포인트
              path: /actuator/health/liveness
              port: 8082
              # scheme: HTTP 또는 HTTPS
              scheme: HTTP
            # initialDelaySeconds: 컨테이너 시작 후 첫 프로브까지 대기 시간
            # Spring Boot 애플리케이션 시작 시간 고려
            initialDelaySeconds: 60
            # periodSeconds: 프로브 실행 간격
            periodSeconds: 10
            # timeoutSeconds: 프로브 응답 대기 시간
            timeoutSeconds: 5
            # successThreshold: 성공으로 판단할 연속 성공 횟수
            successThreshold: 1
            # failureThreshold: 실패로 판단할 연속 실패 횟수
            # 3번 연속 실패 시 컨테이너 재시작
            failureThreshold: 3

          # ----------------------------------------------------------------
          # readinessProbe: 준비 상태 프로브
          # ----------------------------------------------------------------
          # 애플리케이션이 트래픽을 받을 준비가 되었는지 확인
          # 실패 시: Service의 엔드포인트에서 제거 (트래픽 차단)
          #          Pod은 재시작되지 않음
          #
          # 사용 사례:
          # - 애플리케이션 초기화 완료 확인
          # - 의존 서비스 연결 확인
          # - 캐시 워밍업 완료 확인
          #
          # readinessProbe 실패 = 트래픽 차단 (재시작 아님)
          # 외부 의존성 체크 포함 가능
          # ----------------------------------------------------------------
          readinessProbe:
            httpGet:
              # Spring Boot Actuator의 readiness 전용 엔드포인트
              # 이 엔드포인트는 DB, Redis 등의 연결 상태도 확인
              path: /actuator/health/readiness
              port: 8082
              scheme: HTTP
            # initialDelaySeconds: 시작 후 첫 체크까지 대기
            # livenessProbe보다 짧게 설정 (빠른 서비스 투입)
            initialDelaySeconds: 30
            # periodSeconds: 체크 간격
            periodSeconds: 5
            # timeoutSeconds: 응답 대기 시간
            timeoutSeconds: 3
            # successThreshold: 성공으로 판단할 연속 성공 횟수
            successThreshold: 1
            # failureThreshold: 실패로 판단할 연속 실패 횟수
            failureThreshold: 3

          # ----------------------------------------------------------------
          # startupProbe: 시작 프로브 (선택적)
          # ----------------------------------------------------------------
          # 애플리케이션 시작 완료 확인
          # startupProbe가 성공하기 전까지 liveness/readiness 프로브 비활성화
          #
          # 사용 사례:
          # - 시작 시간이 긴 애플리케이션
          # - 초기화 작업이 많은 경우
          #
          # 장점:
          # - livenessProbe의 initialDelaySeconds를 짧게 설정 가능
          # - 시작 시간과 런타임 체크를 분리
          # ----------------------------------------------------------------
          startupProbe:
            httpGet:
              path: /actuator/health
              port: 8082
              scheme: HTTP
            # initialDelaySeconds: 컨테이너 시작 직후부터 체크 시작
            initialDelaySeconds: 10
            # periodSeconds: 체크 간격
            periodSeconds: 5
            # timeoutSeconds: 응답 대기 시간
            timeoutSeconds: 3
            # failureThreshold * periodSeconds = 최대 대기 시간
            # 30 * 5 = 150초 (2분 30초) 내에 시작해야 함
            failureThreshold: 30

          # ----------------------------------------------------------------
          # lifecycle: 컨테이너 라이프사이클 훅
          # ----------------------------------------------------------------
          # 컨테이너 시작/종료 시 특정 작업 수행
          # ----------------------------------------------------------------
          lifecycle:
            # preStop: 컨테이너 종료 직전에 실행
            # Graceful Shutdown을 위해 SIGTERM 전에 대기 시간 확보
            preStop:
              exec:
                # sleep으로 새 트래픽 유입 방지 후 기존 요청 처리 시간 확보
                # Service 엔드포인트에서 제거되는 시간 고려
                command: ["/bin/sh", "-c", "sleep 10"]

      # ----------------------------------------------------------------------
      # imagePullSecrets: 프라이빗 레지스트리 인증 정보
      # ----------------------------------------------------------------------
      # Docker Hub, ECR, GCR 등의 프라이빗 레지스트리에서
      # 이미지를 가져올 때 필요한 인증 정보
      # Secret으로 미리 생성해두어야 함
      # ----------------------------------------------------------------------
      # imagePullSecrets:
      #   - name: docker-registry-secret

      # ----------------------------------------------------------------------
      # affinity: Pod 배치 규칙
      # ----------------------------------------------------------------------
      # 어떤 노드에 Pod을 배치할지 세밀하게 제어
      # 고가용성을 위해 Pod을 여러 노드에 분산 배치
      # ----------------------------------------------------------------------
      affinity:
        # podAntiAffinity: 같은 애플리케이션 Pod을 분산 배치
        podAntiAffinity:
          # preferredDuringSchedulingIgnoredDuringExecution: 선호 조건 (강제 아님)
          # requiredDuringSchedulingIgnoredDuringExecution: 필수 조건
          preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 100
              podAffinityTerm:
                # labelSelector: 분산할 대상 Pod 선택
                labelSelector:
                  matchLabels:
                    app: open-green
                # topologyKey: 분산 기준
                # kubernetes.io/hostname: 노드별로 분산
                # topology.kubernetes.io/zone: 가용 영역별로 분산
                topologyKey: kubernetes.io/hostname

      # ----------------------------------------------------------------------
      # topologySpreadConstraints: 토폴로지 분산 제약 (K8s 1.19+)
      # ----------------------------------------------------------------------
      # 더 세밀한 Pod 분산 제어
      # ----------------------------------------------------------------------
      topologySpreadConstraints:
        - maxSkew: 1  # 최대 불균형 허용치
          # topologyKey: 분산 기준 (노드, 존 등)
          topologyKey: kubernetes.io/hostname
          # whenUnsatisfiable: 조건 불만족 시 행동
          # DoNotSchedule: 스케줄링 안 함
          # ScheduleAnyway: 가능한 균등하게 스케줄링
          whenUnsatisfiable: ScheduleAnyway
          labelSelector:
            matchLabels:
              app: open-green

# ============================================================================
# 사용 명령어 예시
# ============================================================================
#
# 1. Deployment 생성:
#    kubectl apply -f deployment.yaml
#
# 2. Deployment 상태 확인:
#    kubectl get deployment open-green-deployment
#    kubectl describe deployment open-green-deployment
#
# 3. Pod 목록 확인:
#    kubectl get pods -l app=open-green
#
# 4. Pod 로그 확인:
#    kubectl logs -l app=open-green --tail=100 -f
#
# 5. 롤아웃 상태 확인:
#    kubectl rollout status deployment/open-green-deployment
#
# 6. 롤아웃 히스토리:
#    kubectl rollout history deployment/open-green-deployment
#
# 7. 이전 버전으로 롤백:
#    kubectl rollout undo deployment/open-green-deployment
#
# 8. 특정 버전으로 롤백:
#    kubectl rollout undo deployment/open-green-deployment --to-revision=2
#
# 9. 스케일링:
#    kubectl scale deployment open-green-deployment --replicas=3
#
# 10. Pod 내부 접속:
#     kubectl exec -it <pod-name> -- /bin/sh
#
# ============================================================================
