# ============================================================================
# service.yaml - Kubernetes Service 리소스
# ============================================================================
#
# Service란?
# - Pod 집합에 대한 안정적인 네트워크 엔드포인트 제공
# - Pod은 생성/삭제될 때마다 IP가 변경되지만, Service는 고정 IP/DNS 제공
# - 로드 밸런싱: 여러 Pod에 트래픽을 분산
#
# 왜 Service가 필요한가?
# - Pod IP는 임시적 (Pod 재시작 시 변경)
# - Service는 고정된 ClusterIP와 DNS 이름 제공
# - 다른 애플리케이션은 Service 이름으로 접근
#
# Service 타입:
# 1. ClusterIP (기본): 클러스터 내부에서만 접근 가능
# 2. NodePort: 각 노드의 특정 포트로 외부 접근 가능
# 3. LoadBalancer: 클라우드 로드밸런서를 통해 외부 접근
# 4. ExternalName: 외부 DNS 이름을 클러스터 내부 DNS로 매핑
# ============================================================================

apiVersion: v1
kind: Service
metadata:
  # name: Service의 이름
  # 이 이름이 DNS 이름이 됨: <service-name>.<namespace>.svc.cluster.local
  # 예: open-green-service.default.svc.cluster.local
  # 같은 네임스페이스 내에서는 open-green-service로 접근 가능
  name: open-green-service

  # namespace: Service가 속할 네임스페이스
  # Deployment와 같은 네임스페이스에 있어야 함
  namespace: default

  # labels: Service를 분류하기 위한 레이블
  labels:
    app: open-green

  # annotations: 추가 메타데이터
  annotations:
    # 설명 (문서화 목적)
    description: "open-green Spring Boot 애플리케이션 Service"

spec:
  # --------------------------------------------------------------------------
  # type: Service 타입
  # --------------------------------------------------------------------------
  #
  # ClusterIP (선택 이유):
  # - 가장 기본적이고 안전한 타입
  # - 클러스터 내부 통신에 적합
  # - 외부 접근은 Ingress를 통해 제어
  #
  # 타입별 특징:
  # 1. ClusterIP:
  #    - 클러스터 내부 전용
  #    - 기본값이며 가장 많이 사용
  #    - Ingress와 함께 사용하여 외부 노출
  #
  # 2. NodePort:
  #    - 30000-32767 범위의 포트를 모든 노드에서 열음
  #    - 개발/테스트 환경에서 빠른 외부 접근에 유용
  #    - 프로덕션에서는 보안상 비권장
  #
  # 3. LoadBalancer:
  #    - 클라우드 제공자의 로드밸런서 자동 생성
  #    - AWS ELB, GCP Load Balancer 등
  #    - 비용이 발생하며 서비스당 하나의 LB 필요
  #
  # 4. ExternalName:
  #    - 외부 서비스를 클러스터 내부 DNS로 매핑
  #    - 예: RDS, Cloud SQL 등 외부 데이터베이스 접근 시
  # --------------------------------------------------------------------------
  type: ClusterIP

  # --------------------------------------------------------------------------
  # selector: 이 Service가 트래픽을 전달할 Pod 선택
  # --------------------------------------------------------------------------
  # 이 레이블을 가진 Pod들로 트래픽이 라우팅됨
  # Deployment의 template.metadata.labels와 일치해야 함
  # --------------------------------------------------------------------------
  selector:
    app: open-green

  # --------------------------------------------------------------------------
  # ports: 포트 매핑 정의
  # --------------------------------------------------------------------------
  # - port: Service가 노출하는 포트 (다른 Pod이 이 포트로 접근)
  # - targetPort: 실제 컨테이너가 리스닝하는 포트
  # - name: 포트 이름 (여러 포트 시 구분용)
  # --------------------------------------------------------------------------
  ports:
    - name: http
      # protocol: TCP (기본) 또는 UDP
      protocol: TCP
      # port: Service가 노출하는 포트
      # 클라이언트는 이 포트로 접속
      # 예: curl http://open-green-service:80
      port: 80
      # targetPort: 컨테이너의 실제 포트
      # Deployment의 containerPort와 일치해야 함
      # 포트 이름 또는 숫자로 지정 가능
      targetPort: 8082

  # --------------------------------------------------------------------------
  # sessionAffinity: 세션 어피니티 (고정)
  # --------------------------------------------------------------------------
  # 같은 클라이언트의 요청을 같은 Pod으로 라우팅할지 여부
  #
  # - None (기본): 라운드 로빈으로 분산
  # - ClientIP: 클라이언트 IP 기반으로 같은 Pod에 연결
  #
  # Spring Session + Redis 사용 시:
  # - None 권장 (세션이 Redis에 저장되므로 어느 Pod이든 처리 가능)
  #
  # Sticky Session 필요 시:
  # - ClientIP 사용
  # - sessionAffinityConfig로 타임아웃 설정 가능
  # --------------------------------------------------------------------------
  sessionAffinity: None

  # sessionAffinityConfig:
  #   clientIP:
  #     timeoutSeconds: 10800  # 3시간

# ============================================================================
# 추가 Service 예시: NodePort 타입 (개발/테스트용)
# ============================================================================
# 개발 환경에서 Ingress 없이 빠르게 외부 접근이 필요할 때 사용
# kubectl로 직접 포트 포워딩하는 것보다 영구적
# ============================================================================
---
apiVersion: v1
kind: Service
metadata:
  name: open-green-nodeport
  namespace: default
  labels:
    app: open-green
  annotations:
    description: "개발/테스트용 NodePort Service (프로덕션 비권장)"
spec:
  # NodePort: 모든 노드의 특정 포트로 외부 접근 허용
  type: NodePort
  selector:
    app: open-green
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 8082
      # nodePort: 노드에서 열리는 포트
      # 30000-32767 범위 내에서 지정하거나 자동 할당
      # 생략하면 Kubernetes가 자동으로 할당
      nodePort: 30082

# ============================================================================
# Headless Service 예시 (StatefulSet과 함께 사용)
# ============================================================================
# 로드 밸런싱 없이 각 Pod에 직접 접근할 때 사용
# 예: 데이터베이스 클러스터, Kafka, Elasticsearch 등
# ============================================================================
---
apiVersion: v1
kind: Service
metadata:
  name: open-green-headless
  namespace: default
  labels:
    app: open-green
  annotations:
    description: "Headless Service - Pod 직접 접근용"
spec:
  # clusterIP: None으로 설정하면 Headless Service가 됨
  # ClusterIP가 할당되지 않고, DNS 조회 시 모든 Pod IP 반환
  clusterIP: None
  selector:
    app: open-green
  ports:
    - name: http
      protocol: TCP
      port: 8082
      targetPort: 8082

# ============================================================================
# Service 동작 원리 설명
# ============================================================================
#
# 1. DNS 기반 서비스 디스커버리:
#    - Service 생성 시 자동으로 DNS 레코드 생성
#    - <service-name>.<namespace>.svc.cluster.local
#    - 같은 네임스페이스: <service-name>만으로 접근 가능
#
# 2. 엔드포인트(Endpoints):
#    - Service는 selector와 일치하는 Pod의 IP를 자동 추적
#    - kubectl get endpoints open-green-service로 확인
#    - Pod이 Ready 상태일 때만 엔드포인트에 추가
#
# 3. kube-proxy:
#    - 각 노드에서 실행되며 Service의 가상 IP를 관리
#    - iptables 또는 IPVS 규칙으로 트래픽 라우팅
#
# 4. 로드 밸런싱:
#    - 기본적으로 라운드 로빈 방식
#    - 여러 Pod에 균등하게 트래픽 분산
#
# ============================================================================
# 사용 명령어 예시
# ============================================================================
#
# 1. Service 생성:
#    kubectl apply -f service.yaml
#
# 2. Service 목록 확인:
#    kubectl get services
#    kubectl get svc  # 축약형
#
# 3. Service 상세 정보:
#    kubectl describe service open-green-service
#
# 4. 엔드포인트 확인 (연결된 Pod IP 목록):
#    kubectl get endpoints open-green-service
#
# 5. Service DNS 테스트:
#    kubectl run -it --rm debug --image=busybox --restart=Never -- \
#      nslookup open-green-service
#
# 6. Service로 요청 테스트:
#    kubectl run -it --rm debug --image=curlimages/curl --restart=Never -- \
#      curl http://open-green-service:80/actuator/health
#
# 7. NodePort 접근 테스트:
#    curl http://<노드IP>:30082/actuator/health
#    # minikube: minikube service open-green-nodeport --url
#
# 8. 포트 포워딩 (로컬 개발용):
#    kubectl port-forward service/open-green-service 8082:80
#    # 이후 localhost:8082로 접근 가능
#
# ============================================================================
