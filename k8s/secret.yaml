# ============================================================================
# secret.yaml - Kubernetes Secret 리소스
# ============================================================================
#
# Secret이란?
# - 민감한 정보(비밀번호, 토큰, 키 등)를 저장하는 리소스
# - ConfigMap과 유사하지만 보안에 더 중점
# - Base64로 인코딩되어 저장 (암호화가 아님!)
#
# Secret vs ConfigMap:
# - Secret: 민감 정보 (비밀번호, API 키, 인증서)
# - ConfigMap: 비민감 설정 (URL, 포트, 기능 플래그)
#
# 중요한 보안 고려사항:
# 1. Base64는 암호화가 아님! 쉽게 디코딩 가능
# 2. etcd 암호화 설정 권장
# 3. RBAC으로 Secret 접근 제한
# 4. 실제 프로덕션에서는 External Secret Manager 권장
#    (AWS Secrets Manager, HashiCorp Vault 등)
#
# Secret 타입:
# - Opaque: 일반적인 키-값 데이터 (기본)
# - kubernetes.io/tls: TLS 인증서
# - kubernetes.io/dockerconfigjson: Docker 레지스트리 인증
# - kubernetes.io/basic-auth: 기본 인증
# - kubernetes.io/ssh-auth: SSH 인증
# ============================================================================

apiVersion: v1
kind: Secret
metadata:
  # name: Secret 이름
  # Deployment에서 secretKeyRef로 참조할 때 이 이름 사용
  name: open-green-secret

  # namespace: Secret이 속할 네임스페이스
  # 참조하는 Pod과 같은 네임스페이스에 있어야 함
  namespace: default

  # labels: Secret을 분류하기 위한 레이블
  labels:
    app: open-green

  # annotations: 추가 메타데이터
  annotations:
    description: "open-green 애플리케이션 민감 정보"

# --------------------------------------------------------------------------
# type: Secret 타입
# --------------------------------------------------------------------------
# Opaque: 사용자 정의 데이터 (가장 일반적)
# --------------------------------------------------------------------------
type: Opaque

# --------------------------------------------------------------------------
# data: Base64로 인코딩된 데이터
# --------------------------------------------------------------------------
# 모든 값은 Base64로 인코딩되어야 함
#
# 인코딩 방법:
# - Linux/Mac: echo -n 'value' | base64
# - Windows PowerShell: [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes('value'))
# - 온라인 도구: https://www.base64encode.org/
#
# 디코딩 방법:
# - Linux/Mac: echo 'encoded' | base64 -d
# - Windows PowerShell: [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('encoded'))
# --------------------------------------------------------------------------
data:
  # ==========================================================================
  # 데이터베이스 인증 정보
  # ==========================================================================
  # database-username: "root" -> Base64 인코딩 결과
  # echo -n 'root' | base64 -> cm9vdA==
  database-username: cm9vdA==

  # database-password: "your-secure-password" -> Base64 인코딩 필요
  # 예시: "root" -> cm9vdA==
  # 주의: 실제 프로덕션에서는 강력한 비밀번호 사용!
  database-password: cm9vdA==

  # ==========================================================================
  # Redis 인증 정보 (설정된 경우)
  # ==========================================================================
  # Redis에 비밀번호가 설정된 경우에만 필요
  # 빈 문자열도 Base64로 인코딩해야 함
  # echo -n '' | base64 -> (빈 결과)
  # 또는 비밀번호가 있는 경우: echo -n 'redis-password' | base64
  redis-password: ""

  # ==========================================================================
  # 기타 민감 정보 예시
  # ==========================================================================
  # API 키, JWT 시크릿, 외부 서비스 인증 정보 등

  # JWT 시크릿 키 예시
  # "my-jwt-secret-key" -> bXktand0LXNlY3JldC1rZXk=
  # jwt-secret: bXktand0LXNlY3JldC1rZXk=

# --------------------------------------------------------------------------
# stringData: 평문 데이터 (자동으로 Base64 인코딩됨)
# --------------------------------------------------------------------------
# 개발/테스트 시 편리하지만, kubectl get secret -o yaml로 볼 때
# 여전히 Base64로 표시됨
#
# 주의: stringData와 data에 같은 키가 있으면 stringData 우선
# --------------------------------------------------------------------------
stringData:
  # 여기에 평문으로 작성하면 Kubernetes가 자동으로 Base64 인코딩
  # 예시: 새로운 키 추가 시 편리
  # api-key: "your-api-key-here"
  #
  # 하지만 Git에 커밋할 때 평문이 노출되므로 주의!
  # 프로덕션에서는 data 필드 사용 권장
  placeholder: "replace-with-actual-value"

# ============================================================================
# TLS Secret 예시 (Ingress HTTPS용)
# ============================================================================
# 인증서와 개인키를 저장하는 TLS 타입 Secret
# ============================================================================
---
apiVersion: v1
kind: Secret
metadata:
  name: open-green-tls-secret
  namespace: default
  labels:
    app: open-green
# TLS 타입 지정
type: kubernetes.io/tls
data:
  # TLS 인증서 (Base64 인코딩)
  # cat tls.crt | base64 -w0
  # 아래는 예시용 플레이스홀더입니다. 실제 인증서로 교체하세요.
  tls.crt: |
    LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMvVENDQWVXZ0F3SUJBZ0lKQU5S
    TEV4YW1wbGVfY2VydGlmaWNhdGVfcGxhY2Vob2xkZXIKLS0tLS1FTkQgQ0VSVElGSUNB
    VEUtLS0tLQo=

  # TLS 개인키 (Base64 인코딩)
  # cat tls.key | base64 -w0
  # 아래는 예시용 플레이스홀더입니다. 실제 키로 교체하세요.
  tls.key: |
    LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCk1JSUV2Z0lCQURBTkJna3Foa2lHOXcw
    ZXhhbXBsZV9wcml2YXRlX2tleV9wbGFjZWhvbGRlcgotLS0tLUVORCBQUklWQVRFIEtF
    WS0tLS0tCg==

# ============================================================================
# Docker Registry Secret 예시 (프라이빗 레지스트리 인증)
# ============================================================================
# 프라이빗 컨테이너 레지스트리에서 이미지를 가져올 때 필요
# ============================================================================
---
apiVersion: v1
kind: Secret
metadata:
  name: docker-registry-secret
  namespace: default
type: kubernetes.io/dockerconfigjson
data:
  # Docker 설정 JSON (Base64 인코딩)
  # 생성 방법:
  # kubectl create secret docker-registry docker-registry-secret \
  #   --docker-server=<registry-url> \
  #   --docker-username=<username> \
  #   --docker-password=<password> \
  #   --docker-email=<email> \
  #   --dry-run=client -o yaml
  .dockerconfigjson: |
    eyJhdXRocyI6eyJleGFtcGxlLmNvbSI6eyJ1c2VybmFtZSI6InVzZXIiLCJwYXNzd29y
    ZCI6InBhc3MiLCJhdXRoIjoiZFhObGNqcHdZWE56In19fQ==

# ============================================================================
# Secret 보안 모범 사례
# ============================================================================
#
# 1. Git에 Secret YAML 커밋하지 않기
#    - .gitignore에 *secret*.yaml 추가
#    - 또는 Sealed Secrets 사용 (암호화된 형태로 Git 저장)
#
# 2. RBAC으로 Secret 접근 제한
#    - 필요한 서비스 계정에만 접근 권한 부여
#    - kubectl get secret이 가능한 사용자 제한
#
# 3. etcd 암호화 활성화
#    - Kubernetes 클러스터 수준에서 설정
#    - Secret이 암호화된 상태로 저장됨
#
# 4. External Secret Manager 사용 (프로덕션 권장)
#    - AWS Secrets Manager
#    - HashiCorp Vault
#    - Azure Key Vault
#    - Google Secret Manager
#    - External Secrets Operator로 연동
#
# 5. Secret 최소 권한 원칙
#    - 필요한 키만 Pod에 주입
#    - 전체 Secret을 환경변수로 주입하지 않기
#
# ============================================================================
# Secret 사용 방법 (Deployment에서)
# ============================================================================
#
# 방법 1: 개별 키를 환경변수로 주입 (권장)
# ------------------------------------
# env:
#   - name: SPRING_DATASOURCE_PASSWORD
#     valueFrom:
#       secretKeyRef:
#         name: open-green-secret
#         key: database-password
#         optional: false  # 키가 없으면 Pod 시작 실패
#
# 방법 2: Secret 전체를 환경변수로 주입 (비권장)
# ------------------------------------
# envFrom:
#   - secretRef:
#       name: open-green-secret
#     prefix: SECRET_  # 선택: 환경변수 접두어 추가
#
# 방법 3: 볼륨으로 마운트 (파일로 사용)
# ------------------------------------
# volumes:
#   - name: secret-volume
#     secret:
#       secretName: open-green-secret
#       defaultMode: 0400  # 읽기 전용 권한
#       items:
#         - key: database-password
#           path: db-password
#
# containers:
#   - name: open-green
#     volumeMounts:
#       - name: secret-volume
#         mountPath: /secrets
#         readOnly: true
#
# ============================================================================
# 사용 명령어 예시
# ============================================================================
#
# 1. Secret 생성:
#    kubectl apply -f secret.yaml
#
# 2. Secret 목록 확인:
#    kubectl get secrets
#
# 3. Secret 상세 정보 (값은 표시되지 않음):
#    kubectl describe secret open-green-secret
#
# 4. Secret 내용 확인 (Base64 인코딩된 상태):
#    kubectl get secret open-green-secret -o yaml
#
# 5. Secret 값 디코딩:
#    kubectl get secret open-green-secret -o jsonpath='{.data.database-password}' | base64 -d
#
# 6. 명령줄에서 Secret 생성:
#    kubectl create secret generic my-secret \
#      --from-literal=username=admin \
#      --from-literal=password=secret123
#
# 7. 파일에서 Secret 생성:
#    kubectl create secret generic my-secret \
#      --from-file=ssh-privatekey=~/.ssh/id_rsa \
#      --from-file=ssh-publickey=~/.ssh/id_rsa.pub
#
# 8. TLS Secret 생성:
#    kubectl create secret tls my-tls-secret \
#      --cert=path/to/tls.crt \
#      --key=path/to/tls.key
#
# 9. Docker Registry Secret 생성:
#    kubectl create secret docker-registry my-registry-secret \
#      --docker-server=<registry> \
#      --docker-username=<user> \
#      --docker-password=<password>
#
# 10. Secret 삭제:
#     kubectl delete secret open-green-secret
#
# ============================================================================
# Base64 인코딩/디코딩 참고
# ============================================================================
#
# Linux/Mac:
#   인코딩: echo -n 'value' | base64
#   디코딩: echo 'encoded' | base64 -d
#
# Windows PowerShell:
#   인코딩: [Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes('value'))
#   디코딩: [Text.Encoding]::UTF8.GetString([Convert]::FromBase64String('encoded'))
#
# Windows CMD:
#   certutil -encode input.txt encoded.txt
#   certutil -decode encoded.txt output.txt
#
# ============================================================================
